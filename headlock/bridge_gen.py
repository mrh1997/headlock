"""
This module provides the code to generate the bridge code.
"""
from .c_data_model import CStructType, CFuncType, CPointerType, CIntType


def write_bridge_code(output, globals, implementations, py2c_bridge_ndxs):
    output.write(
        '/* This file is automaticially generated by bridge_gen.py. *\n'
        ' * DO NOT MODIFY IT MANUALLY.                             */\n'
        '\n')
    write_required_struct_defs(output, globals)
    write_py2c_bridge(output, globals, py2c_bridge_ndxs)
    write_mock_defs(output, globals, implementations)


def write_required_struct_defs(output, globals):
    for cstruct_type in iter_req_structs_in_dep_order(globals.values()):
        output.write(cstruct_type.c_definition() + ';\n')
    for cstruct_type in iter_req_structs_in_dep_order(globals.values(),
                                                      only_embedded_types=True):
        output.write(cstruct_type.c_definition_full() + ';\n')
    output.write('\n')


def iter_req_structs_in_dep_order(ctypes, only_embedded_types=False):
    processed = set()
    def emb_struct_only(ctype, parent_ctype):
        return not (isinstance(ctype, CStructType)
                    and isinstance(parent_ctype, CPointerType))
    for ctype in ctypes:
        sub_types = ctype.iter_subtypes(
            top_level_last=True,
            filter=emb_struct_only if only_embedded_types else None,
            processed=processed)
        for sub_type in sub_types:
            if isinstance(sub_type, CStructType) \
                    and not sub_type.is_anonymous_struct():
                yield sub_type


def write_py2c_bridge(output, globals, bridge_ndxs):
    output.write(
        'int _py2c_bridge_(int bridge_ndx, void (*func_ptr)(void), '
                        'unsigned char * params, unsigned char * retval)\n'
        '{\n'
        '\tswitch (bridge_ndx)\n'
        '\t{\n')
    for name, ctype in sorted(globals.items()):
        if isinstance(ctype, CFuncType):
            sig_id = ctype.sig_id
            if sig_id not in bridge_ndxs:
                bridge_ndx = bridge_ndxs[sig_id] = len(bridge_ndxs)
                write_py2c_bridge_signature(output, ctype, bridge_ndx)
    output.write(
        '\tdefault:\n'
        '\t\treturn 0;\n'
        '\t}\n'
        '}\n\n\n')
    return bridge_ndxs


def write_py2c_bridge_signature(output, cfunc, bridge_ndx):
    output.write('\tcase ' + str(bridge_ndx) + ':\n'
                 '\t{\n')
    for arg_ndx, arg_ctype in enumerate(cfunc.args):
        param_type = arg_ctype.c_definition('*')
        param_def = arg_ctype.c_definition(f'*_p{arg_ndx}')
        if arg_ndx == 0:
            output.write(f'\t\t{param_def} = ({param_type}) params;\n')
        else:
            output.write(f'\t\t{param_def} = ({param_type}) ((unsigned char *) '
                             f'_p{arg_ndx - 1} + sizeof({prev_param_type}));\n')
        prev_param_type = arg_ctype.c_definition()
    output.write('\t\t')
    if cfunc.returns:
        output.write('*(' + cfunc.returns.c_definition('*') + ') retval = ')
    arg_list = ', '.join(map('*_p{}'.format, range(len(cfunc.args))))
    output.write(f'(* ({cfunc.c_definition("(*)")}) func_ptr)({arg_list});\n')
    output.write('\t\treturn 1;\n'
                 '\t}\n')


def write_mock_defs(output, globals, implementations):
    mocks = {name: type
             for name, type in globals.items()
             if name not in implementations}
    for mock_name, mock in sorted(mocks.items()):
        if not isinstance(mock, CFuncType):
            output.write(mock.c_definition(mock_name) + ';\n')
        else:
            output.write(mock.c_definition(f'(* {mock_name}_mock)') + ' = 0;\n')
            write_mock_redirect_func(output, mock, mock_name)
    output.write('\n')


def write_mock_redirect_func(output, mock, name):
    output.write(mock.c_definition(name) + '\n')
    output.write('{\n')
    output.write('\treturn ' if mock.returns is not None else '\t')
    params = ', '.join(f'p{pndx}' for pndx in range(len(mock.args)))
    output.write(f'(* {name}_mock)({params});\n')
    output.write('}\n')



if __name__ == '__main__':
    import sys
    uint8_t = CIntType('uint8_t', 8, False, 'little')
    int32_t = CIntType('int32_t', 32, True, 'little')
    teststruct = CStructType('teststruct',
                             {'member1': uint8_t, 'member2':int32_t})
    write_bridge_code(
        sys.stdout,
        {
            'testfunc1': CFuncType(uint8_t.ptr,
                                   [teststruct.ptr, int32_t, int32_t.array(3)]),
            'testfunc2': CFuncType(None, [int32_t.ptr, teststruct]),
            'testfunc3': CFuncType(uint8_t.ptr,
                                   [teststruct.ptr, int32_t, int32_t.array(3)])
        },
        {'testfunc1', 'testfunc2'},
        {}
    )
