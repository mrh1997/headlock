"""
This module provides the code to generate the bridge code.
"""
from .c_data_model import CStructType, CFuncType, CPointerType, \
    CIntType, CProxyType
from typing import TextIO, Dict, Iterable, List, Set, Tuple


def write_bridge(output:TextIO,
                 req_typedefs:Set[CProxyType],
                 py2c_funcs:List[CFuncType],
                 c2py_funcs:List[CFuncType],
                 mock_funcs:List[Tuple[str, CFuncType]],
                 mock_vars:Dict[str, CProxyType],
                 c2py_bridges_per_sig:int):
    output.write(
        '/* This file is automaticially generated by bridge_gen.py. *\n'
        ' * DO NOT MODIFY IT MANUALLY.                             */\n'
        '\n'
        'void * (* _c2py_bridge_handler)(int sig_id, int inst_ndx, '
                          'unsigned char * params, unsigned char * retval) '
                '= (void *) 0;\n'
        '\n')
    write_required_typedefs(output, req_typedefs)
    write_mock_vars(output, mock_vars)
    write_py2c_bridge(output, py2c_funcs)
    write_c2py_bridge(output, c2py_funcs, c2py_bridges_per_sig)
    write_mock_funcs(output, mock_funcs)


def write_required_typedefs(output:TextIO, ctypes:Iterable[CProxyType]):
    """
    declares all structs that are required directly or indirectly by one of
    the typedefs 'ctypes'.
    """
    output.write('#include <setjmp.h>\n\n')
    for cstruct_type in iter_req_structs_in_dep_order(ctypes):
        output.write(cstruct_type.get_pure_ctype().c_definition() + ';\n')
    for cstruct_type in iter_req_structs_in_dep_order(ctypes,
                                                      only_embedded_types=True):
        output.write(cstruct_type.get_pure_ctype().c_definition_full() + ';\n')
    output.write('\n')


def iter_req_structs_in_dep_order(ctypes, only_embedded_types=False):
    processed = set()
    def emb_struct_only(ctype, parent_ctype):
        return not (isinstance(ctype, CStructType)
                    and isinstance(parent_ctype, CPointerType))
    for ctype in ctypes:
        sub_types = ctype.iter_subtypes(
            top_level_last=True,
            filter=emb_struct_only if only_embedded_types else None,
            processed=processed)
        for sub_type in sub_types:
            if isinstance(sub_type, CStructType) \
                    and not sub_type.is_anonymous_struct():
                yield sub_type


def write_py2c_bridge(output:TextIO, py2c_funcs:List[CFuncType]):
    output.write(
        'int _py2c_bridge_(long py2c_id, void (*func_ptr)(void), '
                        'unsigned char * params, unsigned char * retval, '
                        'void * * jmp_dest)\n'
        '{\n'
        '\tjmp_buf _jmp_dest;\n'
        '\t*jmp_dest = (void*) &_jmp_dest;\n'
        '\tif (setjmp(_jmp_dest))\n'
        '\t\treturn 2;\n'
        '\tswitch (py2c_id)\n'
        '\t{\n')
    for py2c_func_ndx, py2c_func in enumerate(py2c_funcs):
        output.write('\tcase ' + str(py2c_func_ndx) + ':\n'
                     '\t{\n')
        write_params_ptrs(output, py2c_func.args, indent='\t\t')
        output.write('\t\t')
        if py2c_func.returns:
            c_def_retval = py2c_func.returns.c_definition('*')
            output.write(f'*({c_def_retval}) retval = ')
        arg_list = ', '.join(map('*pp{}'.format,
                                 range(len(py2c_func.args))))
        output.write(f'(* ({py2c_func.c_definition("(*)")}) func_ptr)'
                     f'({arg_list});\n')
        output.write('\t\treturn 1;\n'
                     '\t}\n')
    output.write(
        '\tdefault:\n'
        '\t\treturn 0;\n'
        '\t}\n'
        '}\n\n\n')


def write_c2py_bridge(output:TextIO, c2py_funcs:List[CFuncType],
                      c2py_bridges_per_sig:int):
    for sig_id, cfunctype in enumerate(c2py_funcs):
        for inst_ndx in range(c2py_bridges_per_sig):
            output.write('static ')
            bridge_name = f'_c2py_bridge_sig{sig_id:X}_inst{inst_ndx:X}'
            write_c2py_bridge_func(output, sig_id, inst_ndx,
                                   bridge_name, cfunctype)
    output.write('typedef void (* _c2py_bridge_t)(void);\n\n')
    for sig_id, cfunctype in enumerate(c2py_funcs):
        output.write(
            f'static _c2py_bridge_t _c2py_bridges_sig{sig_id}[] = {{')
        output.write('\t')
        for inst_ndx in range(c2py_bridges_per_sig):
            output.write(
                f'(_c2py_bridge_t) '
                    f'_c2py_bridge_sig{sig_id:X}_inst{inst_ndx:X}, ')
        output.write('};\n')
    output.write('\n_c2py_bridge_t * _c2py_bridges[] = { ')
    for sig_id, cfunctype in enumerate(c2py_funcs):
        output.write(f'_c2py_bridges_sig{sig_id}, ')
    output.write('};\n\n')


def write_c2py_bridge_func(output, sig_id, inst_ndx, name, cfunc):
    output.write(cfunc.c_definition(name) + '\n')
    output.write('{\n')
    params_size = sum(a.sizeof for a in cfunc.args)
    output.write(f'\tunsigned char params[{params_size}];\n')
    write_params_ptrs(output, cfunc.args, indent='\t')
    if cfunc.returns is not None:
        output.write('\t' + cfunc.returns.c_definition('retval') + ';\n')
        retval_str = '(unsigned char *) &retval'
    else:
        retval_str = '(unsigned char *) 0'
    for arg_ndx in range(len(cfunc.args)):
        output.write(f'\t*pp{arg_ndx} = p{arg_ndx};\n')
    output.write(
        f'\tjmp_buf * exc_jump = (jmp_buf*) _c2py_bridge_handler('
        f'{sig_id}, {inst_ndx}, params, {retval_str});\n')
    output.write('\tif (exc_jump) longjmp(*exc_jump, 1);\n')
    if cfunc.returns is not None:
        output.write('\treturn retval;\n')
    output.write('}\n\n')


def write_params_ptrs(output, args, indent=''):
    for arg_ndx, arg_ctype in enumerate(args):
        param_type = arg_ctype.ptr.c_definition()
        param_def =arg_ctype.ptr.with_attr('const').c_definition(f'pp{arg_ndx}')
        if arg_ndx == 0:
            output.write(f'{indent}{param_def} = ({param_type}) params;\n')
        else:
            output.write(f'{indent}{param_def} = ({param_type}) ('
                             f'pp{arg_ndx - 1} + 1);\n')


def write_mock_funcs(output:TextIO, mock_funcs:List[Tuple[str, CFuncType]]):
    for mock_ndx, (mock_name, mock) in enumerate(mock_funcs):
        #TODO: replace -1 by sig_id (not required yet, but ugly)
        write_c2py_bridge_func(output, -1, -(1+mock_ndx), mock_name, mock)
    output.write('\n')


def write_mock_vars(output:TextIO, mock_vars:Dict[str, CProxyType]):
    for mock_name, mock in sorted(mock_vars.items()):
        output.write(mock.c_definition(mock_name) + ';\n')
    output.write('\n')


if __name__ == '__main__':
    import sys
    c_char = CIntType('char', 8, True, 'little')
    c_unsigned = CIntType('unsigned', 32, False, 'little')
    teststruct = CStructType('teststruct',
                             {'member1': c_char, 'member2':c_unsigned})
    functype1 = CFuncType(c_char.ptr,
                          [teststruct.ptr, c_unsigned, c_unsigned.array(3)])
    functype2 = CFuncType(c_unsigned.ptr, [c_char])
    functype3 = CFuncType(c_unsigned, [])
    write_bridge(sys.stdout,
                 {teststruct},
                 [functype1, functype2],
                 [functype2, functype3],
                 [('fmock1', functype1), ('fmock2', functype3)],
                 {'vmock1': c_char.ptr, 'vmock2':c_unsigned},
                 3)
