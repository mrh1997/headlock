"""
This plugin creates a CMakeLists file, that contains all testsetups of the
first (failed) test.
To avoid overwriting this File the "--keep-first-failed-pytest" command line
option can be set.

The content of this file is used by testlibs/debug_failed.py
to run only one test.

In contrary to the builtin cache plugin, this plugin provides the option
--keep-first-failed-pytest. This option allows to avoid overwriting
'CMakeLists.tx' and this rerun a test again and again with
'debug_failed.py' (even if it passed in the last run).

A test is also marked as failed if its execution
stops with a crash (=no teardown executed)
"""
import os
from pathlib import Path
from headlock.testsetup import TestSetup, ToolChainDriver
from .common import PYTEST_HEADLOCK_DIR


master_cmakelist = ''
keep_failed = False


def cmakelists_read_state():
    try:
        lines = open(master_cmakelist, 'r').readlines()
    except IOError:
        lines = []
    if len(lines) < 4:
        return '', 'UNDEFINED'
    else:
        comment1, comment2, first_line, *_, last_line = lines
        if first_line[0] != '#':
            return '', 'UNDEFINED'
        else:
            nodeid = first_line[1:].strip()
            if last_line.strip() not in ('# OK', '# FAILED'):
                return nodeid, 'UNDEFINED'
            else:
                return nodeid, last_line[1:].strip()

def cmakelists_reset(nodeid):
    try:
        with open(master_cmakelist, 'w') as cmfile:
            cmfile.write(f'# DO NOT MODIFY THIS FILE (CREATED BY '
                         f'pytest plugin headlock-cmake)\n')
            cmfile.write(f'#\n')
            cmfile.write(f'# {nodeid}\n')
            cmfile.write(f'cmake_minimum_required(VERSION 3.6)\n')
    except OSError:
        pass

def cmakelists_write_result(result):
    try:
        with open(master_cmakelist, 'a') as cmfile:
            cmfile.write('# ' + result)
    except OSError:
        pass

def initialize():
    try:
        os.remove(master_cmakelist)
    except OSError:
        pass

def start_test(nodeid):
    _, cur_state = cmakelists_read_state()
    if cur_state != 'FAILED':
        cmakelists_reset(nodeid)

def finish_test(nodeid, failed):
    cur_nodeid, cur_failed = cmakelists_read_state()
    if nodeid == cur_nodeid and cur_failed == 'UNDEFINED':
        cmakelists_write_result('FAILED' if failed else 'OK')



#--- PyTest specific interface: ---

def pytest_addoption(parser):
    parser.addoption('--keep-first-failed-pytest',
                     action='store_true', dest='KEEP_FAILED')

def pytest_configure(config):
    global abs_markerfile, master_cmakelist, keep_failed
    keep_failed = config.option.KEEP_FAILED
    if not keep_failed:
        master_cmakelist = os.path.join(config.rootdir,
                                        PYTEST_HEADLOCK_DIR, 'CMakeLists.txt')
        master_cmakelist_dir = os.path.dirname(master_cmakelist)
        if not os.path.exists(master_cmakelist_dir):
            os.mkdir(master_cmakelist_dir)
            gitignore_path = os.path.join(master_cmakelist_dir, '.gitignore')
            with open(gitignore_path, 'wt') as gitignore:
                gitignore.write('# created by pytest-headlock automatically, '
                                'do not change\n*')
        initialize()

def pytest_runtest_setup(item):
    if not keep_failed:
        start_test(item.nodeid)

def pytest_runtest_logreport(report):
    if not keep_failed and report.when == 'call':
        finish_test(report.nodeid, report.failed)


class CMakeToolChain(ToolChainDriver):

    ADDITIONAL_COMPILE_OPTIONS = ['-Werror']
    ADDITIONAL_LINK_OPTIONS = ['-Werror']

    def __init__(self, base_toolchain):
        self.base_toolchain = base_toolchain
        self.ADDITIONAL_COMPILE_OPTIONS = \
            base_toolchain.ADDITIONAL_COMPILE_OPTIONS + \
            self.ADDITIONAL_COMPILE_OPTIONS
        self.ADDITIONAL_LINK_OPTIONS = \
            base_toolchain.ADDITIONAL_LINK_OPTIONS + \
            self.ADDITIONAL_LINK_OPTIONS
        self.CLANG_TARGET = base_toolchain.CLANG_TARGET

    def sys_predef_macros(self):
        return self.base_toolchain.sys_predef_macros()

    def sys_incl_dirs(self):
        return self.base_toolchain.sys_incl_dirs()

    def exe_path(self, name, build_dir):
        return self.base_toolchain.exe_path(name, build_dir)

    @staticmethod
    def escape(str):
        if '"' in str or '(' in str or ')' in str:
            return '"' + str.replace('"', '\\"') + '"'
        else:
            return str

    def generate_cmakelists(self, prj_name, build_dir, transunits,
                            req_libs, lib_dirs):
        yield f'# This file was generated by CMakeToolChain ' \
              f'automaticially.\n' \
              f'# Do not modify it manually!\n' \
              f'\n' \
              f'cmake_minimum_required(VERSION 3.6)\n' \
              f'project({prj_name} C)\n' \
              f'set(CMAKE_C_STANDARD 99)\n' \
              f'\n' \
              f'add_library(TS_{prj_name} SHARED'
        subsys_names = sorted({tu.subsys_name for tu in transunits})
        shortend_prj_name, *_ = prj_name.split('.')
        for subsys_name in subsys_names:
            yield f' $<TARGET_OBJECTS:CMOD_{subsys_name}_{shortend_prj_name}>'
        yield ')\n'
        compile_options = self.base_toolchain.ADDITIONAL_COMPILE_OPTIONS \
                          + self.ADDITIONAL_COMPILE_OPTIONS
        link_options = self.base_toolchain.ADDITIONAL_LINK_OPTIONS \
                       + self.ADDITIONAL_LINK_OPTIONS
        yield f"add_compile_options({' '.join(compile_options)})\n"
        yield f"set(CMAKE_EXE_LINKER_FLAGS \"{' '.join(link_options)}\")\n"
        yield '\n'
        if lib_dirs:
            yield f'link_directories({" ".join(lib_dirs)})\n'
        yield f'set_target_properties(TS_{prj_name} PROPERTIES\n' \
              f'                      RUNTIME_OUTPUT_DIRECTORY ${{CMAKE_CURRENT_SOURCE_DIR}}\n' \
              f'                      OUTPUT_NAME __headlock_dbg__\n' \
              f'                      PREFIX "")\n'
        if req_libs:
            yield f'target_link_libraries(TS_{prj_name} {" ".join(req_libs)})\n'
        yield '\n'
        for subsys_name in subsys_names:
            yield f'add_library(CMOD_{subsys_name}_{shortend_prj_name} OBJECT'
            abs_incl_dirs = []
            predef_macros = {}
            transunits_of_subsys = list(filter(
                lambda tu: tu.subsys_name == subsys_name, transunits))
            for transunit in sorted(transunits_of_subsys):
                rel_path = os.path.relpath(transunit.abs_src_filename,build_dir)
                yield ' ' + str(rel_path).replace('\\', '/')
                abs_incl_dirs = transunit.abs_incl_dirs
                predef_macros = transunit.predef_macros
            yield ')\n'
            yield f'target_compile_definitions(CMOD_{subsys_name}_{shortend_prj_name} PUBLIC'
            for mname, mval in predef_macros.items():
                yield ' '
                yield self.escape(mname + ('' if mval is None else f'={mval}'))
            yield ')\n'
            yield f'target_include_directories(CMOD_{subsys_name}_{shortend_prj_name} PUBLIC'
            for incl_dir in abs_incl_dirs:
                relative_path = os.path.relpath(incl_dir, build_dir)
                yield ' ' + relative_path.replace('\\', '/')
            yield ')\n'
            yield '\n'

    def build(self, name, build_dir, transunits, req_libs, lib_dirs):
        cmakelists_path = build_dir / 'CMakeLists.txt'
        cmakelists_content = ''.join(
            self.generate_cmakelists(name, build_dir, transunits,
                                     req_libs, lib_dirs))
        cmakelists_path.write_text(cmakelists_content)

        if master_cmakelist:
            master_cmakelist_path = Path(master_cmakelist)
            master_cmakelist_dir = master_cmakelist_path.parent.resolve()
            rel_build_dir = os.path.relpath(build_dir,str(master_cmakelist_dir))
            rel_build_dir_str = str(rel_build_dir).replace('\\', '/')
            if master_cmakelist_path.exists():
                lines = master_cmakelist_path.open().readlines()
                if len(lines) >= 4:
                    lastline = lines[-1]
                    if len(lastline) > 0 and lastline[0] != '#':
                        with master_cmakelist_path.open('a') as cmfile:
                            cmfile.write(
                                f'add_subdirectory('
                                f'{rel_build_dir_str} {name})\n')

        self.base_toolchain.build(name, build_dir, transunits,
                                  req_libs, lib_dirs)


TestSetup.__TOOLCHAIN__ = CMakeToolChain(TestSetup.__TOOLCHAIN__)
